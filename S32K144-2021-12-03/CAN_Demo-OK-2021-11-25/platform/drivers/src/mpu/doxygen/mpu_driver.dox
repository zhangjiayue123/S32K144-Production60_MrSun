/*!
   @defgroup mpu Memory Protection Unit (MPU)
   @brief The S32 SDK provides both HAL and Peripheral Driver for the Memory Protection Unit (MPU) module of S32 SDK devices.
   @details The memory protection unit (MPU) provides hardware access control for all memory references generated in the device.@n
    The MPU concurrently monitors all system bus transactions and evaluates their
    appropriateness using pre-programmed region descriptors that define memory spaces and
    their access rights. Memory references that have sufficient access control rights are
    allowed to complete, while references that are not mapped to any region descriptor or
    have insufficient rights are terminated with a protection error response.

   ## Hardware background ##

    The MPU concurrently monitors all system bus transactions and evaluates their
    appropriateness using pre-programmed region descriptors that define memory spaces and
    their access rights. Memory references that have sufficient access control rights are
    allowed to complete, while references that are not mapped to any region descriptor or
    have insufficient rights are terminated with a protection error response.

    The MPU implements a two-dimensional hardware array of memory region descriptors
    and the crossbar slave ports to continuously monitor the legality of every memory
    reference generated by each bus master in the system.

    The feature set includes:
    - 8 program-visible 128-bit region descriptors, accessible by four 32-bit words each
      - Each region descriptor defines a modulo-32 byte space, aligned anywhere in
      memory
        - Region sizes can vary from 32 bytes to 4 Gbytes
      - Two access control permissions defined in a single descriptor word
        - Masters 0–3: read, write, and execute attributes for supervisor and user
          accesses
        - Masters 4–7: read and write attributes
      - Hardware-assisted maintenance of the descriptor valid bit minimizes coherency
        issues
      - Alternate programming model view of the access control permissions word
      - Priority given to granting permission over denying access for overlapping region
        descriptors
    - Detects access protection errors if a memory reference does not hit in any memory
      region, or if the reference is illegal in all hit memory regions. If an access error
      occurs, the reference is terminated with an error response, and the MPU inhibits the
      bus cycle being sent to the targeted slave device
    - Error registers, per slave port, capture the last faulting address, attributes, and other
      information
    - Global MPU enable/disable control bit
 */

/*!
@defgroup mpu_drv MPU Driver
@ingroup mpu

# Pre-Initialization information of MPU module

1. Before using the MPU driver the protocol clock of the module must be configured by the application using PCC module.
2. Bus fault or Hard fault exception must be configured to handle MPU access violation.


## Initialization and Deinitialize{#MPUInit}

To initialize the MPU module, call the MPU_DRV_Init() function and provide the user configuration data structure.
This function sets the configuration of the MPU module automatically and enables the MPU module. \n
Note that the configuration for region 0:
 - Only access right for <b>CORE, DMA</b> can be <b>changed</b> (<b>DEBUG</b> is <b>ignored</b>).
 - The <b>start address</b>, <b>end address</b>, <b>process identifier</b> and <b>process identifier mask</b> are <b>ignored</b>.

This is example code to configure the MPU driver:
~~~~~{.c}
    /* Device instance number */
    #define MEMPROTECT1 (0U)

    /* Number of region in user configuration */
    #define MPU_NUM_OF_REGION_CFG0 (3U)

    /* Master access rights configuration 0 */
    mpu_master_access_right_t AccessRightConfig0[] =
    {
        /* CORE_0 */
        {
            .masterNum = FEATURE_MPU_MASTER_CORE,           /* Master number      */
            .accessRight = MPU_SUPERVISOR_USER_NONE,        /* Access right       */
            .processIdentifierEnable = false                /* Disable identifier */
        },

        /* DEBUGGER_0 */
        {
            .masterNum = FEATURE_MPU_MASTER_DEBUGGER,       /* Master number      */
            .accessRight = MPU_SUPERVISOR_USER_RWX,         /* Access right       */
            .processIdentifierEnable = false                /* Disable identifier */
        },

        /* DMA_0 */
        {
            .masterNum = FEATURE_MPU_MASTER_DMA,            /* Master number      */
            .accessRight = MPU_SUPERVISOR_USER_RW,          /* Access right       */
            .processIdentifierEnable = false                /* Disable identifier */
        }
    };

    /* Master access rights configuration 1 */
    mpu_master_access_right_t AccessRightConfig1[] =
    {
        /* CORE_1 */
        {
            .masterNum = FEATURE_MPU_MASTER_CORE,           /* Master number      */
            .accessRight = MPU_SUPERVISOR_RWX_USER_NONE,    /* Access right       */
            .processIdentifierEnable = false                /* Disable identifier */
        },

        /* DEBUGGER_1 */
        {
            .masterNum = FEATURE_MPU_MASTER_DEBUGGER,       /* Master number      */
            .accessRight = MPU_SUPERVISOR_USER_RWX,         /* Access right       */
            .processIdentifierEnable = false                /* Disable identifier */
        },

        /* DMA_1 */
        {
            .masterNum = FEATURE_MPU_MASTER_DMA,            /* Master number      */
            .accessRight = MPU_SUPERVISOR_USER_RW,          /* Access right       */
            .processIdentifierEnable = false                /* Disable identifier */
        }
    };

    /* Master access rights configuration 2 */
    mpu_master_access_right_t AccessRightConfig2[] =
    {
        /* CORE_2 */
        {
            .masterNum = FEATURE_MPU_MASTER_CORE,           /* Master number      */
            .accessRight = MPU_SUPERVISOR_USER_WX,          /* Access right       */
            .processIdentifierEnable = false                /* Disable identifier */
        },

        /* DEBUGGER_2 */
        {
            .masterNum = FEATURE_MPU_MASTER_DEBUGGER,       /* Master number      */
            .accessRight = MPU_SUPERVISOR_USER_RWX,         /* Access right       */
            .processIdentifierEnable = false                /* Disable identifier */
        },

        /* DMA_2 */
        {
            .masterNum = FEATURE_MPU_MASTER_DMA,            /* Master number      */
            .accessRight = MPU_SUPERVISOR_USER_RW,          /* Access right       */
            .processIdentifierEnable = false                /* Disable identifier */
        }
    };

    /* User configuration 0 */
    const mpu_user_config_t memProtect1_UserConfig0[] =
    {
        /* Region 0 */
        {
            .startAddr      = 0x00000000UL,          /* Memory region start address */
            .endAddr        = 0xFFFFFFFFUL,          /* Memory region end address   */
            .masterAccRight = AccessRightConfig0,    /* Master access right         */
            .processIdentifier  = 0U,                /* Process identifier          */
            .processIdMask  = 0U                     /* Process identifier mask     */
        },

        /* Region 1 */
        {
            .startAddr      = 0x00000000UL,          /* Memory region start address */
            .endAddr        = 0x00080000UL,          /* Memory region end address   */
            .masterAccRight = AccessRightConfig1,    /* Master access right         */
            .processIdentifier  = 0U,                /* Process identifier          */
            .processIdMask  = 0U                     /* Process identifier mask     */
        },

        /* Region 2 */
        {
            .startAddr      = 0x1FF00000UL,          /* Memory region start address */
            .endAddr        = 0x20000000UL,          /* Memory region end address   */
            .masterAccRight = AccessRightConfig2,    /* Master access right         */
            .processIdentifier  = 0U,                /* Process identifier          */
            .processIdMask  = 0U                     /* Process identifier mask     */
        }
    };

    /* Initializes the MPU module */
    MPU_DRV_Init(MEMPROTECT1, MPU_NUM_OF_REGION_CFG0, memProtect1_UserConfig0);
~~~~~

## Basic Control Operations {#MPUBasicOp}

After MPU initialization: @n
The MPU_DRV_Deinit() can be used to reset by default and disable MPU module. @n
The MPU_DRV_SetMasterAccessRights() can be used to change the access rights for special master ports and for special region numbers. @n
The MPU_DRV_SetRegionAddr() can be used to change the start/end address for a region. @n
The MPU_DRV_SetRegionConfig() can be used to set the whole region with the start/end address with access rights. @n
The MPU_DRV_GetDetailErrorAccessInfo() API is provided to get the error status of a special slave port. @n
When an error happens in this port, the MPU_DRV_GetDetailErrorAccessInfo() API is provided to get the detailed error information.

 */
